using FLink.Core.Util;
using FLink.Extensions.DependencyInjection;
using FLink.Metrics.Core;
using FLink.Runtime.Checkpoint;
using FLink.Runtime.IO.Network.Api;
using FLink.Runtime.IO.Network.Api.Writer;
using FLink.Runtime.Pluggable;
using FLink.Streaming.Api.Operators;
using FLink.Streaming.Runtime.IO;
using FLink.Streaming.Runtime.StreamRecords;
using FLink.Streaming.Runtime.StreamStatuses;
using Microsoft.Extensions.Logging;
using System.IO;

namespace FLink.Streaming.Runtime.Tasks
{
    /// <summary>
    /// The <see cref="OperatorChain{TElement,TOperator}"/> contains all operators that are executed as one chain within a single <see cref="StreamTask{TOutput,TOperator}"/>.
    /// </summary>
    /// <typeparam name="TElement">The type of elements accepted by the chain, i.e., the input type of the chain's head operator.</typeparam>
    /// <typeparam name="TOperator"></typeparam>
    public class OperatorChain<TElement, TOperator> : IStreamStatusMaintainer
        where TOperator : IStreamOperator<TElement>
    {
        private static readonly ILogger Logger = ServiceLocator.GetService<ILogger<OperatorChain<TElement, TOperator>>>();

        /// <summary>
        /// Stores all operators on this chain in reverse order.
        /// </summary>
        public IStreamOperator<object>[] AllOperators { get; }

        public RecordWriterOutput<object>[] StreamOutputs { get; }

        public IWatermarkGaugeExposingOutput<StreamRecord<TElement>> ChainEntryPoint { get; }

        public TOperator HeadOperator { get; }

        /// <summary>
        /// Current status of the input stream of the operator chain.
        /// Watermarks explicitly generated by operators in the chain (i.e. timestamp assigner / watermark extractors), will be blocked and not forwarded if this value is <see cref="StreamStatus.Idle"/>
        /// </summary>
        public StreamStatus StreamStatus { get; private set; } = StreamStatus.Active;

        public OperatorChain(
            StreamTask<TElement, TOperator> containingTask,
            IRecordWriterDelegate<SerializationDelegate<StreamRecord<TElement>>> recordWriterDelegate)
        {

        }

        private OperatorChain(
            IStreamOperator<object>[] allOperators,
            RecordWriterOutput<object>[] streamOutputs,
            IWatermarkGaugeExposingOutput<StreamRecord<TElement>> chainEntryPoint,
            TOperator headOperator)
        {
            AllOperators = Preconditions.CheckNotNull(allOperators);
            StreamOutputs = Preconditions.CheckNotNull(streamOutputs);
            ChainEntryPoint = Preconditions.CheckNotNull(chainEntryPoint);
            HeadOperator = Preconditions.CheckNotNull(headOperator);
        }

        public void ToggleStreamStatus(StreamStatus status)
        {
            if (status.Equals(StreamStatus)) return;

            StreamStatus = status;

            // try and forward the stream status change to all outgoing connections.
            foreach (var streamOutput in StreamOutputs)
            {
                streamOutput.EmitStreamStatus(status);
            }
        }

        public void BroadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions)
        {
            var barrier = new CheckpointBarrier(id, timestamp, checkpointOptions);

            foreach (var streamOutput in StreamOutputs)
            {
                streamOutput.BroadcastEvent(barrier);
            }
        }

        public void BroadcastCheckpointCancelMarker(long id)
        {
            var barrier = new CancelCheckpointMarker(id);

            foreach (var streamOutput in StreamOutputs)
            {
                streamOutput.BroadcastEvent(barrier);
            }
        }

        public void PrepareSnapshotPreBarrier(long checkpointId)
        {
            // go forward through the operator chain and tell each operator to prepare the checkpoint
            var operators = AllOperators;

            for (var i = operators.Length - 1; i >= 0; --i)
            {
                operators[i]?.PrepareSnapshotPreBarrier(checkpointId);
            }
        }

        private void EndOperatorInput(IStreamOperator<object> streamOperator, int inputId)
        {
            switch (streamOperator)
            {
                case IBoundedOneInput oneInput:
                    oneInput?.EndInput();
                    break;
                case IBoundedMultiInput multiInput:
                    multiInput?.EndInput(inputId);
                    break;
            }
        }

        /// <summary>
        /// This method should be called before finishing the record emission, to make sure any data that is still buffered will be sent.
        /// It also ensures that all data sending related exceptions are recognized.
        /// </summary>
        /// <exception cref="IOException">Thrown, if the buffered data cannot be pushed into the output streams.</exception>
        public void FlushOutputs()
        {
            foreach (var output in StreamOutputs)
            {
                output.Flush();
            }
        }

        /// <summary>
        /// This method releases all resources of the record writer output.
        /// It stops the output flushing thread(if there is one) and releases all buffers currently held by the output serializers.
        /// </summary>
        public void ReleaseOutputs()
        {
            foreach (var output in StreamOutputs)
            {
                output.Close();
            }
        }

        public int ChainLength => AllOperators?.Length ?? 0;

        public bool HasSelectiveReadingOperator()
        {
            foreach (var @operator in AllOperators)
            {
                if (@operator is IInputSelectable) {
                    return true;
                }
            }

            return false;
        }
}

    /// <summary>
    /// An output that measures the last emitted watermark with a <see cref="WatermarkGauge"/>.
    /// </summary>
    /// <typeparam name="T">The type of the elements that can be emitted.</typeparam>
    public interface IWatermarkGaugeExposingOutput<in T> : IOutput<T>
    {
        IGauge<long> WatermarkGauge { get; }
    }
}
